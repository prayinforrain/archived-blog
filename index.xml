<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PrayinForRain.dev</title><link>https://prayinforrain.github.io/archived-blog/</link><description>Recent content on PrayinForRain.dev</description><generator>Hugo</generator><language>ko</language><lastBuildDate>Thu, 18 Jul 2024 12:34:32 +0900</lastBuildDate><atom:link href="https://prayinforrain.github.io/archived-blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Next.js 성능 개선기</title><link>https://prayinforrain.github.io/archived-blog/posts/2024/07/site-optimization/</link><pubDate>Thu, 18 Jul 2024 12:34:32 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2024/07/site-optimization/</guid><description>최대한 가벼운 사이트를 만들어보자</description></item><item><title>스프레드시트를 최적화 하자</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/11/cell-refactoring/</link><pubDate>Tue, 07 Nov 2023 16:43:32 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/11/cell-refactoring/</guid><description>React로 성능 되찾기</description></item><item><title>차가운 디자인 시스템(CDS) 회고</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/06/cds-retrospect/</link><pubDate>Sun, 18 Jun 2023 16:43:32 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/06/cds-retrospect/</guid><description>우리 v1.2 합시다</description></item><item><title>얀 베리 탐험하기</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/05/exploring-yarn-berry/</link><pubDate>Tue, 30 May 2023 02:27:49 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/05/exploring-yarn-berry/</guid><description>&lt;h2 id="내-레포의-위험한-녀석">내 레포의 위험한 녀석&lt;/h2>
&lt;p>&lt;img src="archived-blog/images/posts/2023/05/exploring-yarn-berry/01.png" alt="cds issue">&lt;/p>
&lt;p>최근 &lt;a href="https://github.com/c-h-w-h/cds">차가운 디자인 시스템(CDS)&lt;/a>의 패키지 매니저를 &lt;strong>Yarn berry&lt;/strong>로 마이그레이션 하는 작업을 하고 있다. 이유는 후술할 &lt;code>node_modules&lt;/code> 자체의 단점도 있고, 내 데스크탑이 HDD를 사용하기 때문에 &lt;code>node_modules&lt;/code>의 수십만 개의 파일들을 다루는 것이 너무 느려서 강력 추천했다.&lt;/p>
&lt;p>하지만 사실 나는 PnP가 어떻게 패키지들을 resolve하는지 전혀 모른다. 그저 어떻게 해야 오류 없이 쓸 수 있는지만 열심히 고민했는데, 팀원들에게 설명할 때 마다 막연히 얀베리가 잘못했겠죠~ 하는 스스로에게 자괴감을 느껴 이 기회에 한 번 Yarn PnP를 똑바로 마주해 보기로 했다.&lt;/p></description></item><item><title>Next.js Storybook에 Yarn PnP 적용하기</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/04/nextjs-storybook-with-pnp/</link><pubDate>Thu, 27 Apr 2023 15:32:50 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/04/nextjs-storybook-with-pnp/</guid><description>&lt;h2 id="storybook을-쓰려고-했는데">Storybook을 쓰려고 했는데&lt;/h2>
&lt;p>최근 Storybook을 사용할 일이 무척 많았다. 언젠가는 포스팅을 해야 할 CDS 프로젝트부터 &lt;a href="https://prayinforrain.github.io/archived-blog/posts/2023/04/numble-talk/">넘블 챌린지&lt;/a>도 있었고&amp;hellip; 처음엔 너무 낯설었지만 공통된 컴포넌트들을 미리 설계해 두고 재사용하는 것이 좀 더 깔끔한 설계가 되는 것 같아 매력을 느꼈다.&lt;/p>
&lt;p>그런데 문제는 내 작업 환경에 있었다. 꽤 연식이 된 윈도우 데스크탑에 수십가지 개발 환경을 섞어 놓고, 요새는 게임에도 못 쓰는 처참한 성능의 HDD에 레포를 두고 쓰니 종속성 패키지 설치도 커피 한 잔 타와야 하는 시간이 걸리니 Yarn Berry의 사용이 반필수가 되어버렸다. 넘블 챌린지 때 Yarn Berry를 사용하고 싶었지만 애석하게도 수 많은 문제에 시달려 포기했는데, 여유가 생긴 지금 마음을 다잡고 다시 시도해 보기로 했다.&lt;/p></description></item><item><title>넘블 OpenAI 단톡방 챌린지 - 프로젝트 회고</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/04/numble-talk/</link><pubDate>Sun, 23 Apr 2023 04:05:58 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/04/numble-talk/</guid><description>&lt;h2 id="시작하게-된-계기">시작하게 된 계기&lt;/h2>
&lt;p>&lt;img src="archived-blog/images/posts/2023/04/numble-talk/01.png" alt="ui design">&lt;/p>
&lt;p>3월에 정말 많은 일들이 있었다. 아직 뭔가 성과라고 내세울 결과물이 없긴 하지만 그래도 무의미하진 않았다(?)고 주장할 수 있는 그런 시간이었다. 점점 일이 정리가 되고 여유가 생기면서 번아웃이 온 사람처럼 푹 늘어지는 느낌이 있었는데, 그 와중에 누가 넘블을 소개해 주셨다.&lt;/p>
&lt;p>대충.. 프로젝트 주제와 요구사항을 주고 구현을 해 보는? 프로세스의 활동으로 이해했다. 기간이 짧아 확 몰입하기 좋겠다는 생각을 해서 한 번 맛만 보기로 했다. OpenAI API를 활용해 보는 프로젝트라는 점이 관심을 끌기도 했다. 요새 챗쌤한테 이런저런 도움도 받았고 관련 아티클도 많이 보이고..&lt;/p></description></item><item><title>백준을 위한 node.js</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/03/nodejs-for-baekjoon/</link><pubDate>Thu, 30 Mar 2023 15:17:00 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/03/nodejs-for-baekjoon/</guid><description>&lt;h2 id="js라도-백준이-하고싶어">JS라도 백준이 하고싶어&lt;/h2>
&lt;p>&lt;img src="archived-blog/images/posts/2023/03/nodejs-for-baekjoon/01.png" alt="Programmers IDE">&lt;/p>
&lt;p>공채 시즌이다. 개인적으로 코딩 테스트를 정말정말 자신 없어했는데, 더 이상 미룰 수 없어 야금야금 공부를 시작했다.&lt;br>
불편한 점이 있다면, 백준은 자바스크립트에 아주 불친절하다는 점이다. 내가 학부생 때 잘 하지도 못하는 C++로 꾸역꾸역 문제를 풀었던 이유 중 하나이기도 했다. 그 때는 아는 PS 플랫폼이 백준 뿐이니, 자바스크립트의 어쩔 수 없는 한계인가보다 했다.&lt;/p>
&lt;p>그런데 프로그래머스를 맛 보고 나니 머리가 커져서 자바스크립트가 백준에게 부당한 차별을 받는(?) 기분이 들었다. 진짜로 화가 난 건 아니지만 그래도 화가 났다. 용서할 수가 없어 보일러플레이트 코드를 작성했다.&lt;/p></description></item><item><title>VSCode의 NPM Scripts가 작동하지 않는 사람</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/03/npm-scripts-doesnt-work/</link><pubDate>Wed, 29 Mar 2023 15:17:00 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/03/npm-scripts-doesnt-work/</guid><description>&lt;figure>&lt;img src="archived-blog/images/posts/2023/03/npm-scripts-doesnt-work/01.jpeg"
 alt="image">&lt;figcaption>
 &lt;p>늦잠자고 갓생사는 척 하는 삶이란&amp;hellip;&lt;/p>
 &lt;/figcaption>
&lt;/figure>

&lt;p>맥북과 친해지기 시작한지 2달이 되었다. 윈도우 노트북을 사용하다가 갈아 탄 이유는, &lt;em>맥에서 되는 것이 윈도우에서 되고, 윈도우에서 되는 것은 맥에서 안되는&lt;/em> 문제를 너무 많이 겪었기 때문이다. 주변의 맥 유저에게 계속해서 테스트를 요청하기도 눈치보이고, 언젠가는 마주해야겠다고 생각했던 녀석이기 때문에 과감한 투자를 했다. 그 과정에서 내가 윈도우에 지나치게 강결합(?) 되어 있다는 것을 깨달았고, 지금은 맥도 윈도우도 못 쓰는 그 어딘가의 지점에 있다.&lt;/p>
&lt;p>그리고 최근에는 프로젝트를 하고 있다. 부스트캠프에서 만난 사람들과 스터디를 하다가, 디자인 시스템을 만들어 보자는 이야기가 나와서 다같이 티스푼 공사 중이다. 이 것에 대해서도 글을 써야 하는데 오늘 포스팅할 내용은 이 것도 아니다. 회고를 안 쓰니 이야기가 많이 밀려 횡설수설 하는구나..&lt;/p></description></item><item><title>Firebase를 TypeScript에서 사용하기</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/02/firebase-with-typescript/</link><pubDate>Wed, 15 Feb 2023 15:17:00 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/02/firebase-with-typescript/</guid><description>&lt;p>최근에 들어서 Firebase가 필요한 일이 있었다. 대학교에서 써본 경험은 있었는데, 오랜만에 만난 Firebase는 예전같지 않았다. 가장 큰 문제는 Firebase가 제공하는 데이터베이스인 Firestore는 문서를 가져와도 타입을 제대로 정의할 수 없다는 것.&lt;/p>
&lt;figure>&lt;img src="archived-blog/images/posts/2023/02/firebase-with-typescript/01.png"
 alt="image">&lt;figcaption>
 &lt;p>자동완성이 안되는 타입스크립트는.. 그.. 왜..?&lt;/p>
 &lt;/figcaption>
&lt;/figure>

&lt;p>물론 데이터스키마를 따로 정의하지 않기 때문에 Firebase 라이브러리가 &lt;code>DocumentData&lt;/code> 타입을 개발자에게 맞춰줄 의무는 없지만, 적어도 &lt;code>React.useState&lt;/code>처럼 제네릭으로 타입을 받아 어느정도 약속해 주기를 바랐다. 아니 바라는게 아니라 되어야 하는 거 아닌가..?&lt;/p>
&lt;h2 id="붕대-감기">붕대 감기&lt;/h2>
&lt;p>우선 Firebase의 쿼리 실행 결과로 오는 &lt;code>DocumentData&lt;/code>는 다음과 같이 정의되어 있다.&lt;/p></description></item><item><title>Typescript Generic</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/02/typescript-generic/</link><pubDate>Wed, 01 Feb 2023 02:01:15 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/02/typescript-generic/</guid><description>&lt;p>타입스크립트와 리액트를 같이 사용할 때, 우리는 &lt;code>useState&lt;/code> 훅을 아래와 같이 사용합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-typescript" data-lang="typescript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">setName&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useState&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">string&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="s2">&amp;#34;지상렬&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>뭔진 몰라도, 저 꺽쇠 괄호를 사용해서 state가 다룰 상태의 타입을 지정할 수가 있습니다. 사실 적지 않아도 알아서 추론해 주지만, 아무튼 &lt;code>name.split('')&lt;/code>처럼 string 타입이 제공하는 메소드나 프로퍼티도 자동완성해주고, 아주 편하게 사용할 수 있습니다. 오늘은 저 꺽쇠괄호에 대해 알아볼거에요.&lt;/p>
&lt;h2 id="any-타입의-문제">any 타입의 문제&lt;/h2>
&lt;p>아무튼 이번에 가져온 예제는 스택(Stack) 자료구조입니다. 그냥 대충 만들게요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-typescript" data-lang="typescript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Stack&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>: &lt;span class="kt">any&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">element&lt;/span>: &lt;span class="kt">any&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">element&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pop() {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-typescript" data-lang="typescript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">stringStack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Stack&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">stringStack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;크와앙&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stringStack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pop&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">slice&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">numberStack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Stack&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">numberStack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">numberStack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pop&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">slice&lt;/span>&lt;span class="p">());&lt;/span> &lt;span class="c1">// TypeError: numberStack.pop(...).slice is not a function
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>당연히 &lt;code>numberStack&lt;/code> 부분에서 에러가 나지만, 이 문제를 &lt;strong>코드를 실행하기 전까진 알 수 없습니다&lt;/strong>. &lt;code>Stack&lt;/code>이 관리하는 것은 &lt;code>any&lt;/code> 타입의 배열이니까요.&lt;/p></description></item><item><title>Hugo로 블로그를 옮기자</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/01/migrating-to-hugo/</link><pubDate>Mon, 30 Jan 2023 19:17:55 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/01/migrating-to-hugo/</guid><description>&lt;p>알음알음 티스푼 공사로 티스토리에서 이 곳으로 블로그를 옮겼습니다. 티스토리에 있던 컨텐츠 대부분은 옮기지 않았습니다. 별 의미도 없고 너무 사적인 내용이 많았기 때문입니다. 또 티스토리만의 감성이라고 해야 하나.. 약간 그 곳에 더 맞는 포인트들이 있어서 아카이브같은 느낌으로 그냥 티스토리에 두기로 했습니다. 곳곳에 티스토리 링크가 있으니 시간을 효율적으로 버리고 싶은 분이 있다면 읽어주셔도 감사할 것 같습니다.
아무튼 옮겨야 하는 컨텐츠도 없으면서 정말 오랜 기간 삽질을 했는데, 그 과정에 대해 이야기해보려고 합니다.&lt;/p>
&lt;h2 id="블로그를-이전하게-된-계기">블로그를 이전하게 된 계기&lt;/h2>
&lt;p>&lt;figure>&lt;img src="archived-blog/images/posts/2023/01/migrating-to-hugo/01.png"
 alt="image">&lt;figcaption>
 &lt;p>아직도 저 Main Page라는 글자의 의미를 모르겠습니다..&lt;/p></description></item><item><title>Tree Shaking</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/01/tree-shaking/</link><pubDate>Wed, 25 Jan 2023 17:17:15 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/01/tree-shaking/</guid><description>&lt;h2 id="용량을-절약하는-방법">용량을 절약하는 방법&lt;/h2>
&lt;p>&lt;img src="archived-blog/images/posts/2023/01/tree-shaking/01.png" alt="bundle_map">&lt;/p>
&lt;p>웹페이지의 성능을 이야기하는 가장 직관적인 지표는 아마 페이지에 사용되는 &lt;strong>파일의 크기&lt;/strong>일 것입니다. 파일의 크기가 무겁다면 파일을 다운받는 데 시간이 오래 걸리고, 다운로드한 파일을 읽고 렌더링 하는데도 시간이 오래 걸릴 것입니다. 따라서 번들 파일의 용량을 다이어트 하는 것은 사이트 성능에 꽤 중요한 역할을 합니다.&lt;/p>
&lt;p>위 사진은 팀 프로젝트를 하던 중 &lt;code>@next/bundle-analyzer&lt;/code> 패키지를 이용해 번들 맵을 그렸던 것입니다. 클수록 번들 용량이 크다는 뜻이니 커다란 청크 위주로 최적화를 시도하면 될 것 같습니다. 그런데 어떻게 용량을 줄일 수 있을까요? gzip을 통해 파일을 압축해서 보내는 방법도 있겠지만, 코드적으로 최적화할 수 있는 방법은 &lt;code>Tree-shaking&lt;/code>입니다.&lt;/p></description></item><item><title>ECMAScript</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/01/ecmascript/</link><pubDate>Wed, 25 Jan 2023 16:35:01 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/01/ecmascript/</guid><description>&lt;p>&lt;img src="archived-blog/images/posts/2023/01/ecmascript/01.png" alt="untitled">&lt;/p>
&lt;h2 id="ecma-international">Ecma international&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>Ecma International&lt;/strong> is an industry association dedicated to the standardization of information and communication systems
&lt;em>Emca International은 정보통신 시스템의 표준화를 위한 국제 표준화 기구입니다.&lt;/em> &amp;gt; &lt;a href="https://www.ecma-international.org/">https://www.ecma-international.org/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>Ecma International은 Ecma 사이트에서 소개하듯, 정보통신 시스템의 표준을 만들기 위한 국제 기구입니다. C#, JSON, .u3d 확장자 등 여러 방면에서의 표준안을 제시하였으며, 개발자를 위한 IEEE같은 존재로 이해하면 될 것 같습니다.(제 생각)&lt;/p>
&lt;p>유럽에서 컴퓨터 시스템을 표준화하기 위해 설립되어서 &lt;strong>ECMA&lt;/strong>(&lt;em>European Computer Manufacturers Association&lt;/em>)라는 이름을 가지고 있으나 유럽국가 뿐 아니라 전세계의 표준으로 활용되기 위해 &lt;strong>Ecma International&lt;/strong>로 이름을 변경하였습니다. &lt;strong>ECMA&lt;/strong> 자체는 두문자어이지만 지금의 이름은 하나의 고유명사로 사용되는 셈이죠. 따라서 &lt;strong>Ecma&lt;/strong>로 표기하는 것이 맞습니다.&lt;/p></description></item><item><title>CSS의 display 속성</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/01/css-display/</link><pubDate>Mon, 16 Jan 2023 16:38:15 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/01/css-display/</guid><description>&lt;p>CSS의 &lt;code>display&lt;/code> 속성은 HTML element가 block인지, inline인지, 그리고 자식 element들을 어떤 식으로 표시할지를 정하는 속성입니다. 다시 말해 요소 자체가 형제 요소와 배치되는 방법과, 자식 요소를 배치하는 방법을 함께 정의하기 때문에 ‘&lt;strong>안쪽&lt;/strong>’과 ‘&lt;strong>바깥쪽&lt;/strong>’으로 속성을 나눌 수 있습니다.&lt;/p>
&lt;h2 id="display">display:&lt;/h2>
&lt;h3 id="바깥쪽">바깥쪽&lt;/h3>
&lt;p>&lt;img src="archived-blog/images/posts/2023/01/css-display/01.png" alt="Untitled">&lt;/p>
&lt;ul>
&lt;li>&lt;code>block&lt;/code>
&lt;ul>
&lt;li>한 줄에는 한 요소만 올 수 있게 하는 속성입니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>inline&lt;/code>
&lt;ul>
&lt;li>요소가 한 줄에 여러 개 표시 될 수 있음을 의미합니다. 만약 &lt;code>inline&lt;/code>이 적용된 요소의 전후에 &lt;code>inline&lt;/code> 요소를 표시할 공간이 있다면 한 줄에 표시됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>사진의 div들은 각각 &lt;code>inline&lt;/code>, &lt;code>block&lt;/code> 속성을 지정하였습니다. 보이는 것과 같이 &lt;code>block&lt;/code> 속성의 요소는 한 줄에 하나만 존재할 수 있으며, &lt;code>inline&lt;/code> 속성은 충분한 공간이 있으면 한 줄에 표시됩니다. &lt;code>span&lt;/code>과 &lt;code>p&lt;/code>태그의 차이와 비슷합니다.&lt;/p></description></item><item><title>브라우저 렌더링과 성능</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/01/browser-rendering-performance/</link><pubDate>Mon, 16 Jan 2023 16:38:15 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/01/browser-rendering-performance/</guid><description>&lt;h2 id="브라우저-렌더링">브라우저 렌더링&lt;/h2>
&lt;p>성능 최적화를 위해, 브라우저가 어떻게 HTML 문서를 화면에 그리는지 과정에 대해 이해할 필요가 있습니다. 브라우저 렌더링은 아래 사진과 같은 흐름으로 이루어집니다.&lt;/p>
&lt;p>&lt;img src="archived-blog/images/posts/2023/01/browser-rendering-performance/01.png" alt="Untitled">&lt;/p>
&lt;ul>
&lt;li>서버로부터 HTML, CSS, JavaScript 파일을 받아와 HTML → DOM, CSS → CSSOM으로 변환하고 Render Tree를 구성합니다.&lt;/li>
&lt;li>Render Tree의 노드들에 대한 위치와 크기를 계산합니다. Render Tree의 루트부터 시작하여 모든 노드에 대해 계산을 수행합니다. (Layout)&lt;/li>
&lt;li>계산된 결과물을 기반으로 화면에 실제 노드들을 그립니다. (Paint)&lt;/li>
&lt;li>사용자의 상호작용이나 스크립트를 통한 제어 등으로 HTML 요소의 크기나 위치의 변경이 일어나면 &lt;code>Reflow&lt;/code>라는 과정을 수행합니다.
&lt;ul>
&lt;li>Reflow는 Render Tree 구성부터 &lt;strong>모든 작업을 다시 수행&lt;/strong>합니다.&lt;/li>
&lt;li>만약 레이아웃 자체에는 변화가 없고, 색상이나 visibility 등의 변경만 있는 경우에는 Paint 과정만을 다시 수행합니다. (Repaint)&lt;/li>
&lt;li>따라서 비용이 큰 &lt;strong>Reflow의 발생을 최대한 줄이는 것이 중요&lt;/strong>합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/TZz9VHjJzMk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>&lt;/iframe>
&lt;p>이거 되게 좋은 내용인 것 같아요 CSS의 &lt;code>will-change&lt;/code>를 통헤 불필요한 GPU 점유를 줄이는 방법도 소개하고 있네요!&lt;/p></description></item><item><title>CSS의 크기 단위</title><link>https://prayinforrain.github.io/archived-blog/posts/2023/01/size-units-in-css/</link><pubDate>Fri, 13 Jan 2023 23:39:15 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2023/01/size-units-in-css/</guid><description>&lt;h2 id="css의-크기-단위">CSS의 크기 단위&lt;/h2>
&lt;p>&lt;img src="archived-blog/images/posts/2023/01/size-units-in-css/01.png" alt="Untitled">&lt;/p>
&lt;p>CSS에는 다양한 단위가 존재합니다. 우리가 잘 아는 &lt;code>px&lt;/code>와 &lt;code>%&lt;/code>부터, &lt;code>em&lt;/code>, &lt;code>rem&lt;/code>, &lt;code>pt&lt;/code>, &lt;code>vh&lt;/code>, &lt;code>vw&lt;/code> 등등 다양한 단위가 존재하는데요, 이 크기 단위들을 언제 어떻게 사용하면 좋을지에 대해 정리해 보았습니다.&lt;/p>
&lt;h2 id="상대-단위와-절대-단위">상대 단위와 절대 단위&lt;/h2>
&lt;p>&lt;code>px&lt;/code>과 &lt;code>%&lt;/code>를 먼저 비교해 보면, &lt;code>px&lt;/code>은 우리가 알고 있는 컴퓨터 화면의 1픽셀을 의미합니다. 이는 어느 화면에서나 같은 크기를 나타내므로 &lt;strong>절대 단위&lt;/strong>에 해당합니다. 반면 &lt;code>%&lt;/code>는 보통 부모 element의 크기를 상속받아 그의 정해진 비율만큼을 나타냅니다. 즉 &lt;code>width: 10px;&lt;/code>인 부모를 가진 element에 &lt;code>width: 50%;&lt;/code>를 주면 5px이 되겠죠. 이렇게 상황에 따라서 다른 값을 갖는 단위를 &lt;strong>상대 단위&lt;/strong>라고 부릅니다.&lt;/p></description></item><item><title>이우재 | Front-end Developer</title><link>https://prayinforrain.github.io/archived-blog/about/</link><pubDate>Mon, 02 Jan 2023 21:38:52 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/about/</guid><description>&lt;ul>
&lt;li>&lt;code>Next.js&lt;/code>와 &lt;code>Typescript&lt;/code>를 주로 사용하여 개발하는 프론트엔드 개발자입니다.&lt;/li>
&lt;li>&lt;strong>말을 할 줄 아는 개발자&lt;/strong>가 되어 커뮤니티에 기여하는 것이 목표입니다.&lt;/li>
&lt;li>저의 이력서는 &lt;a href="https://www.rallit.com/resumes/229210@prayinforrain/%EC%9D%B4%EC%9A%B0%EC%9E%AC">[랠릿]&lt;/a>에서 확인해 주세요.&lt;/li>
&lt;/ul>
&lt;h2 id="techstacks">Techstacks&lt;/h2>
&lt;p>&lt;img src="https://img.shields.io/badge/git-%23F05033.svg?style=flat&amp;amp;logo=git&amp;amp;logoColor=white" alt="Git"> &lt;img src="https://img.shields.io/badge/figma-%23F24E1E.svg?style=flat&amp;amp;logo=figma&amp;amp;logoColor=white" alt="Figma"> &lt;img src="https://img.shields.io/badge/-Storybook-FF4785?style=flat&amp;amp;logo=storybook&amp;amp;logoColor=white" alt="Storybook">&lt;br>
&lt;img src="https://img.shields.io/badge/html5-%23E34F26.svg?style=flat&amp;amp;logo=html5&amp;amp;logoColor=white" alt="HTML5"> &lt;img src="https://img.shields.io/badge/css3-%231572B6.svg?style=flat&amp;amp;logo=css3&amp;amp;logoColor=white" alt="CSS3"> &lt;img src="https://img.shields.io/badge/node.js-6DA55F?style=flat&amp;amp;logo=node.js&amp;amp;logoColor=white" alt="NodeJS"> &lt;img src="https://img.shields.io/badge/typescript-%23007ACC.svg?style=flat&amp;amp;logo=typescript&amp;amp;logoColor=white" alt="TypeScript"> &lt;img src="https://img.shields.io/badge/NPM-%23000000.svg?style=flat&amp;amp;logo=npm&amp;amp;logoColor=white" alt="NPM"> &lt;img src="https://img.shields.io/badge/yarn-%232C8EBB.svg?style=flat&amp;amp;logo=yarn&amp;amp;logoColor=white" alt="Yarn">&lt;br>
&lt;img src="https://img.shields.io/badge/react-%2320232a.svg?style=flat&amp;amp;logo=react&amp;amp;logoColor=%2361DAFB" alt="React"> &lt;img src="https://img.shields.io/badge/Next-black?style=flat&amp;amp;logo=next.js&amp;amp;logoColor=white" alt="Next JS">&lt;br>
&lt;img src="https://img.shields.io/badge/express.js-%23404d59.svg?style=flat&amp;amp;logo=express&amp;amp;logoColor=%2361DAFB" alt="Express.js"> &lt;img src="https://img.shields.io/badge/nestjs-%23E0234E.svg?style=flat&amp;amp;logo=nestjs&amp;amp;logoColor=white" alt="NestJS">&lt;/p>
&lt;h2 id="projects">Projects&lt;/h2>
&lt;ul>
&lt;li>차가운 디자인 시스템, &lt;strong>CDS&lt;/strong> [&lt;a href="https://github.com/c-h-w-h/cds">Repo&lt;/a> | &lt;a href="https://www.npmjs.com/package/@chwh/cds">npm&lt;/a>]&lt;/li>
&lt;li>마크다운을 지원하는 SNS, &lt;strong>모헤윰&lt;/strong> [&lt;a href="https://github.com/boostcampwm-2022/web34-moheyum">Repo&lt;/a> | &lt;a href="https://polarlsm.notion.site/Moheyum-4c54f7ce6bc348bd84121578d4079b50">Notion&lt;/a> | &lt;del>&lt;a href="https://moheyum.ga/">Link&lt;/a>&lt;/del>&lt;em>(expired)&lt;/em> ]&lt;/li>
&lt;/ul>
&lt;h2 id="education">Education&lt;/h2>
&lt;ul>
&lt;li>네이버 커넥트재단 부스트캠프 웹·모바일 7기 (2022.07 ~ 2022.12)&lt;/li>
&lt;li>서울과학기술대학교 컴퓨터공학과 &lt;em>Seoultech Computer Science and Engineering&lt;/em> (2015.03 ~ 2022.02)&lt;/li>
&lt;/ul>
&lt;h2 id="contacts">Contacts&lt;/h2>
&lt;ul>
&lt;li>Email : &lt;a href="mailto:prayinforrain@naver.com">prayinforrain@naver.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://github-readme-stats.vercel.app/api?username=prayinforrain&amp;amp;show_icons=true" alt="PrayinForRain&amp;rsquo;s github stats">&lt;/p></description></item><item><title>모헤윰 mo:heyum - 프로젝트 회고</title><link>https://prayinforrain.github.io/archived-blog/posts/2022/12/finishing-moheyum/</link><pubDate>Wed, 21 Dec 2022 03:30:25 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2022/12/finishing-moheyum/</guid><description>&lt;blockquote>
&lt;p>티스토리 블로그에 작성했던 부스트캠프 팀 프로젝트의 회고 글이다. &lt;a href="https://prayinforrain.tistory.com/80">[원본 링크]&lt;/a>&lt;/p>&lt;/blockquote>
&lt;figure>&lt;img src="archived-blog/images/posts/2022/12/finishing-moheyum/moheyum_01.png"
 alt="image">&lt;figcaption>
 &lt;p>내가 팀원들한테 이 얘길 했나 모르겠는데.. 이 페이지 좀 이쁘다. 잘만드셨다..&lt;/p>
 &lt;/figcaption>
&lt;/figure>

&lt;p>부스트캠프의 최종 팀 프로젝트로 나는 &lt;strong>모헤윰&lt;/strong>이라는 SNS를 만들었다. 결과물은 꽤 괜찮다. &lt;a href="https://youtu.be/9mVinynuUTw">[여기]&lt;/a>에 간단한 시연 영상이 있다. 사실 팀 구인을 하던 때부터 나는 무엇을 만드는지는 크게 중요하지 않았다. 여태까지의 학습 스프린트로 이미 개발이라는 과정은 어느정도 감을 익혔고, 내가 성장함에 따라 이 과정에서 사용하는 기술만 조금씩 변화할 뿐이라고 생각했다. 따라서 내가 팀 프로젝트에서 가장 중요하게 생각했던 포인트는 협업이었다.&lt;/p></description></item><item><title>사이드바야 그만 깜빡여라</title><link>https://prayinforrain.github.io/archived-blog/posts/2022/12/prevent-sidebar-blinking/</link><pubDate>Tue, 06 Dec 2022 02:11:55 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2022/12/prevent-sidebar-blinking/</guid><description>&lt;p>&lt;strong>모헤윰&lt;/strong>의 프론트엔드 앱은 &lt;code>Next.js&lt;/code>로 만들어져 있습니다. 팀원 그 누구도 사용해 본 적이 없음에도 굳이 선택한 이유는 &lt;code>NestJS&lt;/code>를 써 보니 프레임워크를 사용하는 것이 협업 환경에서 코드 일관성을 지키는 데 도움을 줄 것이라는 막연한 기대와, &lt;code>SSR&lt;/code>을 체험해 보고 싶은 학습적인 욕심이 있었습니다. 지금 돌아보니 ‘너와 함께 하길 잘 했어!’ 하는 감상은 없네요.&lt;/p>
&lt;p>기왕 SSR을 체험한다고 시작한 프로젝트인 만큼, 성능에 신경을 쓰지 않을 수 없게 되었습니다. 그러다 제가 좋아하는 어떤 팀의 노션에서 &lt;code>memoization&lt;/code>을 통한 컴포넌트 중복 렌더링 방지에 대한 글을 읽었는데요, 이 부분이 때 마침 &lt;a href="https://www.notion.so/next-js-13-app-dir-11191a66a5564a25ba882c8a835afd13">Next.js 13을 적용하지 못해 포기해야만 했던&lt;/a> 아픈 상처를 자극하고 있어서 모헤윰에도 시도해 보기로 하였습니다.&lt;/p></description></item><item><title>마크다운 만들기 - Markdown [3/3]</title><link>https://prayinforrain.github.io/archived-blog/posts/2022/12/making-editor-markdown/</link><pubDate>Mon, 05 Dec 2022 13:18:55 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2022/12/making-editor-markdown/</guid><description>&lt;p>&lt;strong>모헤윰&lt;/strong>의 에디터 만들기 시리즈 모아보기&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-contenteditable/">에디터 만들기 - ContentEditable [1/3]&lt;/a>&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-getselection/">에디터 만들기 - getSelection [2/3]&lt;/a>&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/12/making-editor-markdown/">에디터 만들기 - Markdown [3/3]&lt;/a>&lt;/p>
&lt;hr>
&lt;p>마지막입니다. 입력하고, 게시할 수 있게 되었으니, 이제 남은 일은 서식을 적용하는 것 뿐입니다. 마크다운 문법을 이용해 어떻게 서식을 적용할 수 있을까요? 그 과정을 정리해 보겠습니다.&lt;/p>
&lt;h2 id="-어떻게-할까요">🤷 어떻게 할까요?&lt;/h2>
&lt;p>정말이지 어떻게 하면 좋을까요? 우선 제가 생각하는 가장 사용성이 좋은 마크다운은 깃허브의 그것이였습니다. &lt;a href="https://github.github.com/gfm/">GFM(GitHub Flavored Markdown)&lt;/a>이라고 부르는 스펙이 있는데, 처음에는 이걸 부르는 이름이 있는 것조차 모르고 막무가내로 리버스 엔지니어링 마인드로 작업을 시작했습니다. 아래 사진처럼 아무 이슈나 들어가서 댓글 창에 실험을 하면서요.&lt;/p></description></item><item><title>마크다운 만들기 - getSelection [2/3]</title><link>https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-getselection/</link><pubDate>Thu, 24 Nov 2022 00:53:55 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-getselection/</guid><description>&lt;p>&lt;strong>모헤윰&lt;/strong>의 에디터 만들기 시리즈 모아보기&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-contenteditable/">에디터 만들기 - ContentEditable [1/3]&lt;/a>&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-getselection/">에디터 만들기 - getSelection [2/3]&lt;/a>&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/12/making-editor-markdown/">에디터 만들기 - Markdown [3/3]&lt;/a>&lt;/p>
&lt;hr>
&lt;p>아니???????? 두 번째 글이 파서가 아니였네요. 저는 사실 이 글이 2부작이길 간절히 바랬는데, 1편에서 만든 에디터에 너무 끔찍한 버그가 있어서 이에 대해 정리해 보고자 합니다. 이걸로 3시간을 씨름하고 있었지만 모헤윰의 TIL 문서가 풍성해지고 있으니 긍정적이게 생각해야겠죠?&lt;/p>
&lt;blockquote>
&lt;p>💡 이 글은 Window 10, Chrome 107.0.5304.107 버전을 기준으로 작성되었습니다. 일부 환경에 따라 다르게 작동하는 부분이 있을 수 있습니다.&lt;/p></description></item><item><title>마크다운 만들기 - contentEditable [1/3]</title><link>https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-contenteditable/</link><pubDate>Tue, 22 Nov 2022 20:36:55 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-contenteditable/</guid><description>&lt;p>&lt;strong>모헤윰&lt;/strong>의 에디터 만들기 시리즈 모아보기&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-contenteditable/">에디터 만들기 - ContentEditable [1/3]&lt;/a>&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/11/making-editor-getselection/">에디터 만들기 - getSelection [2/3]&lt;/a>&lt;br>
&lt;a href="https://prayinforrain.github.io/archived-blog/posts/2022/12/making-editor-markdown/">에디터 만들기 - Markdown [3/3]&lt;/a>&lt;/p>
&lt;hr>
&lt;p>모헤윰의 핵심 기능 중 하나는 &lt;code>마크다운 서식 지원&lt;/code>입니다. 왜 SNS에 마크다운을 끼얹을 생각을 했나 생각해보면 최초 기획부터 있다가 기능 다이어트를 한 후 살아남았기 때문인데, 아무튼 드디어 때가 왔습니다.&lt;/p>
&lt;p>내부적으로 에디터를 외부 라이브러리를 사용하는게 좋지 않겠냐는 이야기가 나왔는데요, 결국 직접 구현해 보기로 했지만 그 과정에서 여러 레퍼런스를 얻을 수 있었습니다. 개인적으로 멋있다고 생각한 사이트 두 가지를 소개합니다.&lt;/p></description></item><item><title>Emotion</title><link>https://prayinforrain.github.io/archived-blog/posts/2022/11/emotion/</link><pubDate>Fri, 18 Nov 2022 16:42:55 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2022/11/emotion/</guid><description>&lt;h2 id="tldr">🤷TL;DR&lt;/h2>
&lt;ul>
&lt;li>CSS-in-JS는 프로젝트 규모가 커질수록 관리하기 어려운 CSS의 문제를 보완한다.&lt;/li>
&lt;li>emotion과 styled-components는 사용상의 차이가 거의 없으니 골라서 사용하자.&lt;/li>
&lt;li>적절한 IDE Extension을 잘 활용하자.&lt;/li>
&lt;li>CSS-in-JS가 모든 경우에 대한 정답이 아님을 인지하자.&lt;/li>
&lt;/ul>
&lt;h2 id="css-in-js">🎨CSS-in-JS&lt;/h2>
&lt;p>CSS-in-JS는 HTML Element의 스타일을 자바스크립트 파일을 통해서 지정하는 방식입니다. .css 파일이 하던 일을 .js 파일에게 시키는 것이죠. CSS는 CSS이고, JS는 JS입니다. 왜 굳이 둘을 합쳐야만 하는 것일까요? 이 알 수 없는 발상을 이해하려면 우선 기존 css의 단점을 살펴보겠습니다.&lt;/p>
&lt;p>&lt;img src="archived-blog/images/posts/2022/11/emotion/emotion_01.png" alt="Untitled">&lt;/p></description></item><item><title>npm vs yarn vs pnpm</title><link>https://prayinforrain.github.io/archived-blog/posts/2022/11/npm-vs-yarn-vs-pnpm/</link><pubDate>Fri, 18 Nov 2022 16:42:55 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2022/11/npm-vs-yarn-vs-pnpm/</guid><description>&lt;p>지금까지 저는 아무 의심 없이 npm을 사용해왔습니다. 이따금씩 &lt;code>node_modules&lt;/code> 폴더가 저를 고통스럽게 했던 시간들이 있었지만, 프로젝트 초기화에 정말 이상한 행동만 하지 않으면 &lt;code>npm i&lt;/code> 한 줄과 커피 한 잔으로 모든게 문제 없이 동작했으니까요. 하지만 우리는 슬랙의 어떤 분을 통해, npm보다 좋은 방법이 있음을 알고 있습니다. 이번 포스트에서는 &lt;code>yarn&lt;/code>과 &lt;code>pnpm&lt;/code>을 체험해 보도록 하겠습니다.&lt;/p>
&lt;h2 id="-tldr">🤷 TL;DR&lt;/h2>
&lt;ul>
&lt;li>npm의 의존성 관리는 사실 매우 비효율적이다.&lt;/li>
&lt;li>이 문제를 보완한 패키지 매니저가 yarn, pnpm이다.&lt;/li>
&lt;li>각 패키지 매니저로의 마이그레이션은 매우 쉽다. 긍정적으로 고려해보자.&lt;/li>
&lt;/ul>
&lt;h2 id="-npm">🎁 npm&lt;/h2>
&lt;p>&lt;img src="archived-blog/images/posts/2022/11/npm-vs-yarn-vs-pnpm/npm_vs_yarn_01.png" alt="Untitled">&lt;/p></description></item><item><title>Redux vs Recoil</title><link>https://prayinforrain.github.io/archived-blog/posts/2022/11/redux-vs-recoil/</link><pubDate>Fri, 18 Nov 2022 16:42:55 +0900</pubDate><guid>https://prayinforrain.github.io/archived-blog/posts/2022/11/redux-vs-recoil/</guid><description>&lt;h2 id="-tldr">🤷 TL;DR&lt;/h2>
&lt;ul>
&lt;li>Redux는 안정적이지만, 선언과 사용이 복잡하다.&lt;/li>
&lt;li>Recoil은 사용이 매우 쉽지만 정식 버전이 없다.&lt;/li>
&lt;li>프로젝트 규모에 따라 마음에 드는 라이브러리를 선택하자&lt;/li>
&lt;/ul>
&lt;h2 id="-서론">🚪 서론&lt;/h2>
&lt;p>우리는 React를 사용할 때 보통 &lt;code>useState&lt;/code>를 통해 상태를 관리합니다. &lt;code>useState&lt;/code>는 정말 섹시하지만, 한 가지 너무 큰 단점이 있습니다. 바로 컴포넌트끼리 데이터를 주고받는 데 사용하기가 힘들다는 점입니다. 그 일을 하기 위해 등장한 것이 바로 &lt;strong>상태 관리 라이브러리&lt;/strong>입니다. 상태 관리 라이브러리의 필요성에 대해 공감하지 못하는 분들을 위해 짧은 토막글을 마련해 보았습니다.&lt;/p></description></item></channel></rss>