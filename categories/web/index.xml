<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on PrayinForRain.dev</title><link>https://prayinforrain.github.io/categories/web/</link><description>Recent content in Web on PrayinForRain.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Mon, 15 Apr 2024 16:43:32 +0900</lastBuildDate><atom:link href="https://prayinforrain.github.io/categories/web/index.xml" rel="self" type="application/rss+xml"/><item><title>스프레드시트를 최적화 하자</title><link>https://prayinforrain.github.io/posts/2023/11/cell-refactoring/</link><pubDate>Tue, 07 Nov 2023 16:43:32 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/11/cell-refactoring/</guid><description>React로 성능 되찾기</description></item><item><title>차가운 디자인 시스템(CDS) 회고</title><link>https://prayinforrain.github.io/posts/2023/06/cds-retrospect/</link><pubDate>Sun, 18 Jun 2023 16:43:32 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/06/cds-retrospect/</guid><description>우리 v1.2 합시다</description></item><item><title>Typescript Generic</title><link>https://prayinforrain.github.io/posts/2023/02/typescript-generic/</link><pubDate>Wed, 01 Feb 2023 02:01:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/02/typescript-generic/</guid><description>타입스크립트와 리액트를 같이 사용할 때, 우리는 useState 훅을 아래와 같이 사용합니다.
const [name, setName] = useState&amp;lt;string&amp;gt;(&amp;#34;지상렬&amp;#34;); 뭔진 몰라도, 저 꺽쇠 괄호를 사용해서 state가 다룰 상태의 타입을 지정할 수가 있습니다. 사실 적지 않아도 알아서 추론해 주지만, 아무튼 name.split('')처럼 string 타입이 제공하는 메소드나 프로퍼티도 자동완성해주고, 아주 편하게 사용할 수 있습니다. 오늘은 저 꺽쇠괄호에 대해 알아볼거에요.
any 타입의 문제 아무튼 이번에 가져온 예제는 스택(Stack) 자료구조입니다. 그냥 대충 만들게요.
class Stack { arr: any[] = []; push(element: any) { this.</description></item><item><title>Tree Shaking</title><link>https://prayinforrain.github.io/posts/2023/01/tree-shaking/</link><pubDate>Wed, 25 Jan 2023 17:17:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/tree-shaking/</guid><description>용량을 절약하는 방법 웹페이지의 성능을 이야기하는 가장 직관적인 지표는 아마 페이지에 사용되는 파일의 크기일 것입니다. 파일의 크기가 무겁다면 파일을 다운받는 데 시간이 오래 걸리고, 다운로드한 파일을 읽고 렌더링 하는데도 시간이 오래 걸릴 것입니다. 따라서 번들 파일의 용량을 다이어트 하는 것은 사이트 성능에 꽤 중요한 역할을 합니다.
위 사진은 팀 프로젝트를 하던 중 @next/bundle-analyzer 패키지를 이용해 번들 맵을 그렸던 것입니다. 클수록 번들 용량이 크다는 뜻이니 커다란 청크 위주로 최적화를 시도하면 될 것 같습니다.</description></item><item><title>ECMAScript</title><link>https://prayinforrain.github.io/posts/2023/01/ecmascript/</link><pubDate>Wed, 25 Jan 2023 16:35:01 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/ecmascript/</guid><description>Ecma international Ecma International is an industry association dedicated to the standardization of information and communication systems Emca International은 정보통신 시스템의 표준화를 위한 국제 표준화 기구입니다. &amp;gt; https://www.ecma-international.org/
Ecma International은 Ecma 사이트에서 소개하듯, 정보통신 시스템의 표준을 만들기 위한 국제 기구입니다. C#, JSON, .u3d 확장자 등 여러 방면에서의 표준안을 제시하였으며, 개발자를 위한 IEEE같은 존재로 이해하면 될 것 같습니다.(제 생각)
유럽에서 컴퓨터 시스템을 표준화하기 위해 설립되어서 ECMA(European Computer Manufacturers Association)라는 이름을 가지고 있으나 유럽국가 뿐 아니라 전세계의 표준으로 활용되기 위해 Ecma International로 이름을 변경하였습니다.</description></item><item><title>CSS의 display 속성</title><link>https://prayinforrain.github.io/posts/2023/01/css-display/</link><pubDate>Mon, 16 Jan 2023 16:38:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/css-display/</guid><description>CSS의 display 속성은 HTML element가 block인지, inline인지, 그리고 자식 element들을 어떤 식으로 표시할지를 정하는 속성입니다. 다시 말해 요소 자체가 형제 요소와 배치되는 방법과, 자식 요소를 배치하는 방법을 함께 정의하기 때문에 ‘안쪽’과 ‘바깥쪽’으로 속성을 나눌 수 있습니다.
display: 바깥쪽 block 한 줄에는 한 요소만 올 수 있게 하는 속성입니다. inline 요소가 한 줄에 여러 개 표시 될 수 있음을 의미합니다. 만약 inline이 적용된 요소의 전후에 inline 요소를 표시할 공간이 있다면 한 줄에 표시됩니다.</description></item><item><title>브라우저 렌더링과 성능</title><link>https://prayinforrain.github.io/posts/2023/01/browser-rendering-performance/</link><pubDate>Mon, 16 Jan 2023 16:38:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/browser-rendering-performance/</guid><description>브라우저 렌더링 성능 최적화를 위해, 브라우저가 어떻게 HTML 문서를 화면에 그리는지 과정에 대해 이해할 필요가 있습니다. 브라우저 렌더링은 아래 사진과 같은 흐름으로 이루어집니다.
서버로부터 HTML, CSS, JavaScript 파일을 받아와 HTML → DOM, CSS → CSSOM으로 변환하고 Render Tree를 구성합니다. Render Tree의 노드들에 대한 위치와 크기를 계산합니다. Render Tree의 루트부터 시작하여 모든 노드에 대해 계산을 수행합니다. (Layout) 계산된 결과물을 기반으로 화면에 실제 노드들을 그립니다. (Paint) 사용자의 상호작용이나 스크립트를 통한 제어 등으로 HTML 요소의 크기나 위치의 변경이 일어나면 Reflow라는 과정을 수행합니다.</description></item><item><title>CSS의 크기 단위</title><link>https://prayinforrain.github.io/posts/2023/01/size-units-in-css/</link><pubDate>Fri, 13 Jan 2023 23:39:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/size-units-in-css/</guid><description>CSS의 크기 단위 CSS에는 다양한 단위가 존재합니다. 우리가 잘 아는 px와 %부터, em, rem, pt, vh, vw 등등 다양한 단위가 존재하는데요, 이 크기 단위들을 언제 어떻게 사용하면 좋을지에 대해 정리해 보았습니다.
상대 단위와 절대 단위 px과 %를 먼저 비교해 보면, px은 우리가 알고 있는 컴퓨터 화면의 1픽셀을 의미합니다. 이는 어느 화면에서나 같은 크기를 나타내므로 절대 단위에 해당합니다. 반면 %는 보통 부모 element의 크기를 상속받아 그의 정해진 비율만큼을 나타냅니다. 즉 width: 10px;인 부모를 가진 element에 width: 50%;를 주면 5px이 되겠죠.</description></item></channel></rss>