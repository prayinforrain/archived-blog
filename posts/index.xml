<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on PrayinForRain.dev</title><link>https://prayinforrain.github.io/posts/</link><description>Recent content in Posts on PrayinForRain.dev</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Mon, 15 Apr 2024 16:43:32 +0900</lastBuildDate><atom:link href="https://prayinforrain.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>스프레드시트를 최적화 하자</title><link>https://prayinforrain.github.io/posts/2023/11/cell-refactoring/</link><pubDate>Tue, 07 Nov 2023 16:43:32 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/11/cell-refactoring/</guid><description>React로 성능 되찾기</description></item><item><title>차가운 디자인 시스템(CDS) 회고</title><link>https://prayinforrain.github.io/posts/2023/06/cds-retrospect/</link><pubDate>Sun, 18 Jun 2023 16:43:32 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/06/cds-retrospect/</guid><description>우리 v1.2 합시다</description></item><item><title>얀 베리 탐험하기</title><link>https://prayinforrain.github.io/posts/2023/05/exploring-yarn-berry/</link><pubDate>Tue, 30 May 2023 02:27:49 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/05/exploring-yarn-berry/</guid><description>내 레포의 위험한 녀석 최근 차가운 디자인 시스템(CDS)의 패키지 매니저를 Yarn berry로 마이그레이션 하는 작업을 하고 있다. 이유는 후술할 node_modules 자체의 단점도 있고, 내 데스크탑이 HDD를 사용하기 때문에 node_modules의 수십만 개의 파일들을 다루는 것이 너무 느려서 강력 추천했다.
하지만 사실 나는 PnP가 어떻게 패키지들을 resolve하는지 전혀 모른다. 그저 어떻게 해야 오류 없이 쓸 수 있는지만 열심히 고민했는데, 팀원들에게 설명할 때 마다 막연히 얀베리가 잘못했겠죠~ 하는 스스로에게 자괴감을 느껴 이 기회에 한 번 Yarn PnP를 똑바로 마주해 보기로 했다.</description></item><item><title>Next.js Storybook에 Yarn PnP 적용하기</title><link>https://prayinforrain.github.io/posts/2023/04/nextjs-storybook-with-pnp/</link><pubDate>Thu, 27 Apr 2023 15:32:50 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/04/nextjs-storybook-with-pnp/</guid><description>Storybook을 쓰려고 했는데 최근 Storybook을 사용할 일이 무척 많았다. 언젠가는 포스팅을 해야 할 CDS 프로젝트부터 넘블 챌린지도 있었고&amp;hellip; 처음엔 너무 낯설었지만 공통된 컴포넌트들을 미리 설계해 두고 재사용하는 것이 좀 더 깔끔한 설계가 되는 것 같아 매력을 느꼈다.
그런데 문제는 내 작업 환경에 있었다. 꽤 연식이 된 윈도우 데스크탑에 수십가지 개발 환경을 섞어 놓고, 요새는 게임에도 못 쓰는 처참한 성능의 HDD에 레포를 두고 쓰니 종속성 패키지 설치도 커피 한 잔 타와야 하는 시간이 걸리니 Yarn Berry의 사용이 반필수가 되어버렸다.</description></item><item><title>넘블 OpenAI 단톡방 챌린지 - 프로젝트 회고</title><link>https://prayinforrain.github.io/posts/2023/04/numble-talk/</link><pubDate>Sun, 23 Apr 2023 04:05:58 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/04/numble-talk/</guid><description>시작하게 된 계기 3월에 정말 많은 일들이 있었다. 아직 뭔가 성과라고 내세울 결과물이 없긴 하지만 그래도 무의미하진 않았다(?)고 주장할 수 있는 그런 시간이었다. 점점 일이 정리가 되고 여유가 생기면서 번아웃이 온 사람처럼 푹 늘어지는 느낌이 있었는데, 그 와중에 누가 넘블을 소개해 주셨다.
대충.. 프로젝트 주제와 요구사항을 주고 구현을 해 보는? 프로세스의 활동으로 이해했다. 기간이 짧아 확 몰입하기 좋겠다는 생각을 해서 한 번 맛만 보기로 했다. OpenAI API를 활용해 보는 프로젝트라는 점이 관심을 끌기도 했다.</description></item><item><title>백준을 위한 node.js</title><link>https://prayinforrain.github.io/posts/2023/03/nodejs-for-baekjoon/</link><pubDate>Thu, 30 Mar 2023 15:17:00 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/03/nodejs-for-baekjoon/</guid><description>JS라도 백준이 하고싶어 공채 시즌이다. 개인적으로 코딩 테스트를 정말정말 자신 없어했는데, 더 이상 미룰 수 없어 야금야금 공부를 시작했다.
불편한 점이 있다면, 백준은 자바스크립트에 아주 불친절하다는 점이다. 내가 학부생 때 잘 하지도 못하는 C++로 꾸역꾸역 문제를 풀었던 이유 중 하나이기도 했다. 그 때는 아는 PS 플랫폼이 백준 뿐이니, 자바스크립트의 어쩔 수 없는 한계인가보다 했다.
그런데 프로그래머스를 맛 보고 나니 머리가 커져서 자바스크립트가 백준에게 부당한 차별을 받는(?) 기분이 들었다. 진짜로 화가 난 건 아니지만 그래도 화가 났다.</description></item><item><title>VSCode의 NPM Scripts가 작동하지 않는 사람</title><link>https://prayinforrain.github.io/posts/2023/03/npm-scripts-doesnt-work/</link><pubDate>Wed, 29 Mar 2023 15:17:00 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/03/npm-scripts-doesnt-work/</guid><description>늦잠자고 갓생사는 척 하는 삶이란&amp;hellip;
맥북과 친해지기 시작한지 2달이 되었다. 윈도우 노트북을 사용하다가 갈아 탄 이유는, 맥에서 되는 것이 윈도우에서 되고, 윈도우에서 되는 것은 맥에서 안되는 문제를 너무 많이 겪었기 때문이다. 주변의 맥 유저에게 계속해서 테스트를 요청하기도 눈치보이고, 언젠가는 마주해야겠다고 생각했던 녀석이기 때문에 과감한 투자를 했다. 그 과정에서 내가 윈도우에 지나치게 강결합(?) 되어 있다는 것을 깨달았고, 지금은 맥도 윈도우도 못 쓰는 그 어딘가의 지점에 있다.
그리고 최근에는 프로젝트를 하고 있다.</description></item><item><title>Firebase를 TypeScript에서 사용하기</title><link>https://prayinforrain.github.io/posts/2023/02/firebase-with-typescript/</link><pubDate>Wed, 15 Feb 2023 15:17:00 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/02/firebase-with-typescript/</guid><description>최근에 들어서 Firebase가 필요한 일이 있었다. 대학교에서 써본 경험은 있었는데, 오랜만에 만난 Firebase는 예전같지 않았다. 가장 큰 문제는 Firebase가 제공하는 데이터베이스인 Firestore는 문서를 가져와도 타입을 제대로 정의할 수 없다는 것.
자동완성이 안되는 타입스크립트는.. 그.. 왜..?
물론 데이터스키마를 따로 정의하지 않기 때문에 Firebase 라이브러리가 DocumentData 타입을 개발자에게 맞춰줄 의무는 없지만, 적어도 React.useState처럼 제네릭으로 타입을 받아 어느정도 약속해 주기를 바랐다. 아니 바라는게 아니라 되어야 하는 거 아닌가..?
붕대 감기 우선 Firebase의 쿼리 실행 결과로 오는 DocumentData는 다음과 같이 정의되어 있다.</description></item><item><title>Typescript Generic</title><link>https://prayinforrain.github.io/posts/2023/02/typescript-generic/</link><pubDate>Wed, 01 Feb 2023 02:01:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/02/typescript-generic/</guid><description>타입스크립트와 리액트를 같이 사용할 때, 우리는 useState 훅을 아래와 같이 사용합니다.
const [name, setName] = useState&amp;lt;string&amp;gt;(&amp;#34;지상렬&amp;#34;); 뭔진 몰라도, 저 꺽쇠 괄호를 사용해서 state가 다룰 상태의 타입을 지정할 수가 있습니다. 사실 적지 않아도 알아서 추론해 주지만, 아무튼 name.split('')처럼 string 타입이 제공하는 메소드나 프로퍼티도 자동완성해주고, 아주 편하게 사용할 수 있습니다. 오늘은 저 꺽쇠괄호에 대해 알아볼거에요.
any 타입의 문제 아무튼 이번에 가져온 예제는 스택(Stack) 자료구조입니다. 그냥 대충 만들게요.
class Stack { arr: any[] = []; push(element: any) { this.</description></item><item><title>Hugo로 블로그를 옮기자</title><link>https://prayinforrain.github.io/posts/2023/01/migrating-to-hugo/</link><pubDate>Mon, 30 Jan 2023 19:17:55 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/migrating-to-hugo/</guid><description>알음알음 티스푼 공사로 티스토리에서 이 곳으로 블로그를 옮겼습니다. 티스토리에 있던 컨텐츠 대부분은 옮기지 않았습니다. 별 의미도 없고 너무 사적인 내용이 많았기 때문입니다. 또 티스토리만의 감성이라고 해야 하나.. 약간 그 곳에 더 맞는 포인트들이 있어서 아카이브같은 느낌으로 그냥 티스토리에 두기로 했습니다. 곳곳에 티스토리 링크가 있으니 시간을 효율적으로 버리고 싶은 분이 있다면 읽어주셔도 감사할 것 같습니다. 아무튼 옮겨야 하는 컨텐츠도 없으면서 정말 오랜 기간 삽질을 했는데, 그 과정에 대해 이야기해보려고 합니다.
블로그를 이전하게 된 계기 아직도 저 Main Page라는 글자의 의미를 모르겠습니다.</description></item><item><title>Tree Shaking</title><link>https://prayinforrain.github.io/posts/2023/01/tree-shaking/</link><pubDate>Wed, 25 Jan 2023 17:17:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/tree-shaking/</guid><description>용량을 절약하는 방법 웹페이지의 성능을 이야기하는 가장 직관적인 지표는 아마 페이지에 사용되는 파일의 크기일 것입니다. 파일의 크기가 무겁다면 파일을 다운받는 데 시간이 오래 걸리고, 다운로드한 파일을 읽고 렌더링 하는데도 시간이 오래 걸릴 것입니다. 따라서 번들 파일의 용량을 다이어트 하는 것은 사이트 성능에 꽤 중요한 역할을 합니다.
위 사진은 팀 프로젝트를 하던 중 @next/bundle-analyzer 패키지를 이용해 번들 맵을 그렸던 것입니다. 클수록 번들 용량이 크다는 뜻이니 커다란 청크 위주로 최적화를 시도하면 될 것 같습니다.</description></item><item><title>ECMAScript</title><link>https://prayinforrain.github.io/posts/2023/01/ecmascript/</link><pubDate>Wed, 25 Jan 2023 16:35:01 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/ecmascript/</guid><description>Ecma international Ecma International is an industry association dedicated to the standardization of information and communication systems Emca International은 정보통신 시스템의 표준화를 위한 국제 표준화 기구입니다. &amp;gt; https://www.ecma-international.org/
Ecma International은 Ecma 사이트에서 소개하듯, 정보통신 시스템의 표준을 만들기 위한 국제 기구입니다. C#, JSON, .u3d 확장자 등 여러 방면에서의 표준안을 제시하였으며, 개발자를 위한 IEEE같은 존재로 이해하면 될 것 같습니다.(제 생각)
유럽에서 컴퓨터 시스템을 표준화하기 위해 설립되어서 ECMA(European Computer Manufacturers Association)라는 이름을 가지고 있으나 유럽국가 뿐 아니라 전세계의 표준으로 활용되기 위해 Ecma International로 이름을 변경하였습니다.</description></item><item><title>CSS의 display 속성</title><link>https://prayinforrain.github.io/posts/2023/01/css-display/</link><pubDate>Mon, 16 Jan 2023 16:38:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/css-display/</guid><description>CSS의 display 속성은 HTML element가 block인지, inline인지, 그리고 자식 element들을 어떤 식으로 표시할지를 정하는 속성입니다. 다시 말해 요소 자체가 형제 요소와 배치되는 방법과, 자식 요소를 배치하는 방법을 함께 정의하기 때문에 ‘안쪽’과 ‘바깥쪽’으로 속성을 나눌 수 있습니다.
display: 바깥쪽 block 한 줄에는 한 요소만 올 수 있게 하는 속성입니다. inline 요소가 한 줄에 여러 개 표시 될 수 있음을 의미합니다. 만약 inline이 적용된 요소의 전후에 inline 요소를 표시할 공간이 있다면 한 줄에 표시됩니다.</description></item><item><title>브라우저 렌더링과 성능</title><link>https://prayinforrain.github.io/posts/2023/01/browser-rendering-performance/</link><pubDate>Mon, 16 Jan 2023 16:38:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/browser-rendering-performance/</guid><description>브라우저 렌더링 성능 최적화를 위해, 브라우저가 어떻게 HTML 문서를 화면에 그리는지 과정에 대해 이해할 필요가 있습니다. 브라우저 렌더링은 아래 사진과 같은 흐름으로 이루어집니다.
서버로부터 HTML, CSS, JavaScript 파일을 받아와 HTML → DOM, CSS → CSSOM으로 변환하고 Render Tree를 구성합니다. Render Tree의 노드들에 대한 위치와 크기를 계산합니다. Render Tree의 루트부터 시작하여 모든 노드에 대해 계산을 수행합니다. (Layout) 계산된 결과물을 기반으로 화면에 실제 노드들을 그립니다. (Paint) 사용자의 상호작용이나 스크립트를 통한 제어 등으로 HTML 요소의 크기나 위치의 변경이 일어나면 Reflow라는 과정을 수행합니다.</description></item><item><title>CSS의 크기 단위</title><link>https://prayinforrain.github.io/posts/2023/01/size-units-in-css/</link><pubDate>Fri, 13 Jan 2023 23:39:15 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2023/01/size-units-in-css/</guid><description>CSS의 크기 단위 CSS에는 다양한 단위가 존재합니다. 우리가 잘 아는 px와 %부터, em, rem, pt, vh, vw 등등 다양한 단위가 존재하는데요, 이 크기 단위들을 언제 어떻게 사용하면 좋을지에 대해 정리해 보았습니다.
상대 단위와 절대 단위 px과 %를 먼저 비교해 보면, px은 우리가 알고 있는 컴퓨터 화면의 1픽셀을 의미합니다. 이는 어느 화면에서나 같은 크기를 나타내므로 절대 단위에 해당합니다. 반면 %는 보통 부모 element의 크기를 상속받아 그의 정해진 비율만큼을 나타냅니다. 즉 width: 10px;인 부모를 가진 element에 width: 50%;를 주면 5px이 되겠죠.</description></item><item><title>모헤윰 mo:heyum - 프로젝트 회고</title><link>https://prayinforrain.github.io/posts/2022/12/finishing-moheyum/</link><pubDate>Wed, 21 Dec 2022 03:30:25 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2022/12/finishing-moheyum/</guid><description>티스토리 블로그에 작성했던 부스트캠프 팀 프로젝트의 회고 글이다. [원본 링크]
내가 팀원들한테 이 얘길 했나 모르겠는데.. 이 페이지 좀 이쁘다. 잘만드셨다..
부스트캠프의 최종 팀 프로젝트로 나는 모헤윰이라는 SNS를 만들었다. 결과물은 꽤 괜찮다. [여기]에 간단한 시연 영상이 있다. 사실 팀 구인을 하던 때부터 나는 무엇을 만드는지는 크게 중요하지 않았다. 여태까지의 학습 스프린트로 이미 개발이라는 과정은 어느정도 감을 익혔고, 내가 성장함에 따라 이 과정에서 사용하는 기술만 조금씩 변화할 뿐이라고 생각했다. 따라서 내가 팀 프로젝트에서 가장 중요하게 생각했던 포인트는 협업이었다.</description></item><item><title>사이드바야 그만 깜빡여라</title><link>https://prayinforrain.github.io/posts/2022/12/prevent-sidebar-blinking/</link><pubDate>Tue, 06 Dec 2022 02:11:55 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2022/12/prevent-sidebar-blinking/</guid><description>모헤윰의 프론트엔드 앱은 Next.js로 만들어져 있습니다. 팀원 그 누구도 사용해 본 적이 없음에도 굳이 선택한 이유는 NestJS를 써 보니 프레임워크를 사용하는 것이 협업 환경에서 코드 일관성을 지키는 데 도움을 줄 것이라는 막연한 기대와, SSR을 체험해 보고 싶은 학습적인 욕심이 있었습니다. 지금 돌아보니 ‘너와 함께 하길 잘 했어!’ 하는 감상은 없네요.
기왕 SSR을 체험한다고 시작한 프로젝트인 만큼, 성능에 신경을 쓰지 않을 수 없게 되었습니다. 그러다 제가 좋아하는 어떤 팀의 노션에서 memoization을 통한 컴포넌트 중복 렌더링 방지에 대한 글을 읽었는데요, 이 부분이 때 마침 Next.</description></item><item><title>마크다운 만들기 - Markdown [3/3]</title><link>https://prayinforrain.github.io/posts/2022/12/making-editor-markdown/</link><pubDate>Mon, 05 Dec 2022 13:18:55 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2022/12/making-editor-markdown/</guid><description>모헤윰의 에디터 만들기 시리즈 모아보기
에디터 만들기 - ContentEditable [1/3]
에디터 만들기 - getSelection [2/3]
에디터 만들기 - Markdown [3/3]
마지막입니다. 입력하고, 게시할 수 있게 되었으니, 이제 남은 일은 서식을 적용하는 것 뿐입니다. 마크다운 문법을 이용해 어떻게 서식을 적용할 수 있을까요? 그 과정을 정리해 보겠습니다.
🤷 어떻게 할까요? 정말이지 어떻게 하면 좋을까요? 우선 제가 생각하는 가장 사용성이 좋은 마크다운은 깃허브의 그것이였습니다. GFM(GitHub Flavored Markdown)이라고 부르는 스펙이 있는데, 처음에는 이걸 부르는 이름이 있는 것조차 모르고 막무가내로 리버스 엔지니어링 마인드로 작업을 시작했습니다.</description></item><item><title>마크다운 만들기 - getSelection [2/3]</title><link>https://prayinforrain.github.io/posts/2022/11/making-editor-getselection/</link><pubDate>Thu, 24 Nov 2022 00:53:55 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2022/11/making-editor-getselection/</guid><description>모헤윰의 에디터 만들기 시리즈 모아보기
에디터 만들기 - ContentEditable [1/3]
에디터 만들기 - getSelection [2/3]
에디터 만들기 - Markdown [3/3]
아니???????? 두 번째 글이 파서가 아니였네요. 저는 사실 이 글이 2부작이길 간절히 바랬는데, 1편에서 만든 에디터에 너무 끔찍한 버그가 있어서 이에 대해 정리해 보고자 합니다. 이걸로 3시간을 씨름하고 있었지만 모헤윰의 TIL 문서가 풍성해지고 있으니 긍정적이게 생각해야겠죠?
💡 이 글은 Window 10, Chrome 107.0.5304.107 버전을 기준으로 작성되었습니다. 일부 환경에 따라 다르게 작동하는 부분이 있을 수 있습니다.</description></item><item><title>마크다운 만들기 - contentEditable [1/3]</title><link>https://prayinforrain.github.io/posts/2022/11/making-editor-contenteditable/</link><pubDate>Tue, 22 Nov 2022 20:36:55 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2022/11/making-editor-contenteditable/</guid><description>모헤윰의 에디터 만들기 시리즈 모아보기
에디터 만들기 - ContentEditable [1/3]
에디터 만들기 - getSelection [2/3]
에디터 만들기 - Markdown [3/3]
모헤윰의 핵심 기능 중 하나는 마크다운 서식 지원입니다. 왜 SNS에 마크다운을 끼얹을 생각을 했나 생각해보면 최초 기획부터 있다가 기능 다이어트를 한 후 살아남았기 때문인데, 아무튼 드디어 때가 왔습니다.
내부적으로 에디터를 외부 라이브러리를 사용하는게 좋지 않겠냐는 이야기가 나왔는데요, 결국 직접 구현해 보기로 했지만 그 과정에서 여러 레퍼런스를 얻을 수 있었습니다. 개인적으로 멋있다고 생각한 사이트 두 가지를 소개합니다.</description></item><item><title>Emotion</title><link>https://prayinforrain.github.io/posts/2022/11/emotion/</link><pubDate>Fri, 18 Nov 2022 16:42:55 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2022/11/emotion/</guid><description>🤷TL;DR CSS-in-JS는 프로젝트 규모가 커질수록 관리하기 어려운 CSS의 문제를 보완한다. emotion과 styled-components는 사용상의 차이가 거의 없으니 골라서 사용하자. 적절한 IDE Extension을 잘 활용하자. CSS-in-JS가 모든 경우에 대한 정답이 아님을 인지하자. 🎨CSS-in-JS CSS-in-JS는 HTML Element의 스타일을 자바스크립트 파일을 통해서 지정하는 방식입니다. .css 파일이 하던 일을 .js 파일에게 시키는 것이죠. CSS는 CSS이고, JS는 JS입니다. 왜 굳이 둘을 합쳐야만 하는 것일까요? 이 알 수 없는 발상을 이해하려면 우선 기존 css의 단점을 살펴보겠습니다.
제가 학습 스프린트때 진행한 프로젝트 파일의 일부입니다.</description></item><item><title>npm vs yarn vs pnpm</title><link>https://prayinforrain.github.io/posts/2022/11/npm-vs-yarn-vs-pnpm/</link><pubDate>Fri, 18 Nov 2022 16:42:55 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2022/11/npm-vs-yarn-vs-pnpm/</guid><description>지금까지 저는 아무 의심 없이 npm을 사용해왔습니다. 이따금씩 node_modules 폴더가 저를 고통스럽게 했던 시간들이 있었지만, 프로젝트 초기화에 정말 이상한 행동만 하지 않으면 npm i 한 줄과 커피 한 잔으로 모든게 문제 없이 동작했으니까요. 하지만 우리는 슬랙의 어떤 분을 통해, npm보다 좋은 방법이 있음을 알고 있습니다. 이번 포스트에서는 yarn과 pnpm을 체험해 보도록 하겠습니다.
🤷 TL;DR npm의 의존성 관리는 사실 매우 비효율적이다. 이 문제를 보완한 패키지 매니저가 yarn, pnpm이다. 각 패키지 매니저로의 마이그레이션은 매우 쉽다.</description></item><item><title>Redux vs Recoil</title><link>https://prayinforrain.github.io/posts/2022/11/redux-vs-recoil/</link><pubDate>Fri, 18 Nov 2022 16:42:55 +0900</pubDate><guid>https://prayinforrain.github.io/posts/2022/11/redux-vs-recoil/</guid><description>🤷 TL;DR Redux는 안정적이지만, 선언과 사용이 복잡하다. Recoil은 사용이 매우 쉽지만 정식 버전이 없다. 프로젝트 규모에 따라 마음에 드는 라이브러리를 선택하자 🚪 서론 우리는 React를 사용할 때 보통 useState를 통해 상태를 관리합니다. useState는 정말 섹시하지만, 한 가지 너무 큰 단점이 있습니다. 바로 컴포넌트끼리 데이터를 주고받는 데 사용하기가 힘들다는 점입니다. 그 일을 하기 위해 등장한 것이 바로 상태 관리 라이브러리입니다. 상태 관리 라이브러리의 필요성에 대해 공감하지 못하는 분들을 위해 짧은 토막글을 마련해 보았습니다.</description></item></channel></rss>